# Webpack tutorial

## 1. Основные концепции

По своей сути, webpack — это сборщик статических модулей для современных приложений JavaScript. Когда веб-пакет обрабатывает ваше приложение, он внутри себя строит граф зависимостей из одной или нескольких точек входа, а затем объединяет каждый модуль, необходимый вашему проекту, в один или несколько пакетов, которые представляют собой статические ресурсы для обслуживания вашего контента.

### 1) Entry:

Точка входа указывает, какой модуль веб-пакета следует использовать, чтобы начать построение внутреннего графа зависимостей. Webpack выяснит, от каких других модулей и библиотек зависит эта точка входа (прямо или косвенно). По умолчанию его значение — ``./src/index.js``, но вы можете указать другие (или несколько) точек входа, установив свойство в конфигурации веб-пакета.
Например:

```javascript
module.exports = {
  entry: './path/to/my/entry/file.js',
};
```

### 2) Output:

Свойство вывода сообщает Webpack, куда отправлять создаваемые им пакеты и как называть эти файлы. По умолчанию это ``./dist/main.js`` для основного выходного файла и папка ``./dist`` для любого другого сгенерированного файла. Вы можете настроить эту часть процесса, указав поле вывода в вашей конфигурации:

```javascript
module.exports = {
  entry: './path/to/my/entry/file.js',
  output: {
    path: path.resolve(__dirname, 'dist'), // Место сборки
    filename: 'my-first-webpack.bundle.js', // Имя пакета
  },
};
```

### 3) Loaders:

По умолчанию веб-пакет понимает только файлы JavaScript и JSON. Загрузчики позволяют веб-пакету обрабатывать файлы других типов и преобразовывать их в допустимые модули, которые могут использоваться вашим приложением и добавляться в граф зависимостей.

_Одной из особенностей веб-пакета является возможность импорта модулей любого типа, например. Файлы .css, которые могут не поддерживаться другими сборщиками или средствами запуска задач. Мы считаем, что такое расширение языка оправдано, поскольку оно позволяет разработчикам строить более точный граф зависимостей._

На высоком уровне загрузчики имеют два свойства в конфигурации вашего Webpack:

1. Свойство ``test`` определяет, какой файл или файлы следует преобразовать
2. Свойство ``use`` указывает, какой загрузчик следует использовать для преобразования.

```javascript
module.exports = {
  output: {
    filename: 'my-first-webpack.bundle.js',
  },
  module: {
    rules: [{ test: /\.txt$/, use: 'raw-loader' }],
  },
};
```

### 4) Plugins:

В то время как загрузчики используются для преобразования определенных типов модулей, плагины можно использовать для выполнения более широкого спектра задач, таких как оптимизация пакетов, управление ассетами и внедрение переменных среды.

Чтобы использовать плагин, вам нужно вызвать его ``require()`` и добавить в массив плагинов. Большинство плагинов настраиваются с помощью опций. Поскольку вы можете использовать плагин несколько раз в конфигурации для разных целей, вам необходимо создать его экземпляр, вызвав его с оператором ``new``.

```javascript
const HtmlWebpackPlugin = require('html-webpack-plugin');
const webpack = require('webpack'); // Для доступа к встроенным плагинам

module.exports = {
  module: {
    rules: [{ test: /\.txt$/, use: 'raw-loader' }],
  },
  plugins: [new HtmlWebpackPlugin({ template: './src/index.html' })],
};
```

_В приведенном выше примере ``html-webpack-plugin`` генерирует HTML-файл для вашего приложения и автоматически вставляет в этот файл все сгенерированные вами пакеты._

### 5) Mode:

Установив для параметра режима значение «development», «production» или «none», вы можете включить встроенные оптимизации веб-пакета, соответствующие каждой среде. Значением по умолчанию является «development».

```javascript
module.exports = {
  mode: 'production',
};
```

### 6) Browser Compatibility:

Webpack поддерживает все браузеры, совместимые с ES5 (IE8 и ниже не поддерживаются). Webpack нуждается в Promise для import() и require.ensure(). Если вы хотите поддерживать старые браузеры, вам нужно будет загрузить полифилл перед использованием этих выражений

_Будем использовать Babel, потому своместимость с браузерами нас не интересует. Полифилы не нужны._